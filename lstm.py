import pandas as pd
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM
from matplotlib import pyplot as plt

""" TODO: Define class LSTM with functions for training, testing and saving the
model and trained weights"""


class LSTM_Models:

    def generate_enc_data(sequence, n_unique=100):
        unique_seq = sequence.unique()
        encoded = np.zeros((len(sequence), len(unique_seq)))
        for i in range(len(sequence)):
            for j in range(len(unique_seq)):
                if sequence[i] == unique_seq[j]:
                    encoded[i][j] = 1
                else:
                    encoded[i][j] = 0
        df = pd.DataFrame(encoded)
        df = pd.concat([df.shift(4),
                        df.shift(3),
                        df.shift(2),
                        df.shift(1),
                        df],
                       axis=1)
        val = df.values
        val = val[5:, :]
        X = val.reshape(len(val), 5, len(unique_seq))
        y = encoded[4:-1, :]
        return X, y

    def decode_op(yhat, sequence):
        decoded = np.zeros((len(yhat), 1))
        unique_seq = sequence.unique()
        yhat_oh_enc = [np.argmax(yhat_vec) for yhat_vec in yhat]
        for i in range(len(yhat_oh_enc)):
            for j in range(len(unique_seq)):
                if yhat_oh_enc[i] == j:
                    decoded[i] = unique_seq[j]
        return decoded

    def single_feature_vanilla_lstm(self,
                                    neurons=16,
                                    n_steps=16,
                                    n_outputs=30):
        model = Sequential()
        model.add(LSTM(neurons, batch_input_shape=(3, 5, n_outputs),
                       stateful=True))
        model.add(Dense(n_outputs))
        model.compile(optimizer='adam', loss='mse')
        return model

    def multiple_feature_vanilla_lstm(self,
                                      neurons=16,
                                      n_steps=16,
                                      n_features=4,
                                      n_outputs=30):
        model = Sequential()
        model.add(LSTM(neurons, batch_input_shape=(3, 5, n_outputs),
                       stateful=True))
        model.add(Dense(n_outputs))
        model.compile(optimizer='adam', loss='mse')
        return model


if __name__ == "__main__":
    file_path = "./data/F.txt"
    signal_df = pd.read_csv(file_path, delimiter="\t",
                            names=['Inst1', 'Inst2', 'Inst3', 'Inst4'])
    print(signal_df.head())
    print("Read input file into dataframe")
    lstm_mods = LSTM_Models()
    # Single feature LSTM with
    sfvl_mod = lstm_mods.single_feature_vanilla_lstm(
        n_outputs=len(signal_df['Inst1'].unique()))
    X, y = LSTM_Models.generate_enc_data(signal_df['Inst1'],
                                         len(signal_df['Inst1'].unique()))
    sfvl_mod.fit(X,
                 y,
                 epochs=1,
                 batch_size=3,
                 verbose=1,
                 shuffle=False)
    yhat = sfvl_mod.predict(X, batch_size=3)
    yhat_df = pd.DataFrame(LSTM_Models.decode_op(yhat, signal_df['Inst1']))
    yhat_df.to_csv("./data/lstm_sfvl_op.csv")
    # Plotting the output generated by the LSTM against the input signal
    plt.plot(signal_df['Inst1'], color='red', label='Inst1')
    plt.plot(yhat_df, color='blue', label='LSTM - Inst1')
    plt.legend(title='Instrument')
    plt.xlabel('Time Step')
    plt.ylabel('Key Number')
    plt.title('Key Number by Time Step')
    plt.savefig('./data/lstm_sfvl_i1.png')
